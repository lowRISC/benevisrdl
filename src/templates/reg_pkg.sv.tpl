// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Package auto-generated by `rdl2ot` containing data structure

package {{ ip_name }}_reg_pkg;

  // Param list

  {%- for item in localparams %}
  parameter {{ item.type|lower }} {{ item.name }} = {{ item.value }};
  {%- endfor %}

  ///////////////////////////////////////////////
  // Typedefs for registers for regs interface //
  ///////////////////////////////////////////////
{% for reg in registers -%}
  {%- set is_multireg = (reg.offsets|length > 1) %}
  {%- set is_multifield = reg.fields|length > 1 %}
  {%- set indent = "  " if is_multifield %}
  {%- if reg.hw_readable %}
  typedef struct packed {
    {%- for field in reg.fields  %}
      {%- if is_multifield %}
    struct packed {
      {%- endif %}
      {%- if field.hw_readable %}
        {%- set bits = "[{}:0]".format(field.width - 1) if field.width > 1 else " " %}
    {{ indent }}logic {{ "{:<6}".format(bits) }} q;
    {{ indent }}logic        qe;
      {%- endif %}
      {%- if is_multifield %}
    } {{ field.name|lower }};
      {%- endif %}
    {%- endfor %}
  } {{ ip_name }}_reg2hw_{{ reg.name|lower }}_{{"m" if is_multireg}}reg_t;
{% endif -%}
{%- endfor -%}

{%- for reg in registers  %}
  {%- set is_multireg = (reg.offsets|length > 1) %}
  {%- set is_multifield = reg.fields|length > 1 %}
  {%- set indent = "  " if is_multifield %}
  {%- if reg.hw_writable %}
  typedef struct packed {
    {%- for field in reg.fields  %}
      {%- if is_multifield %}
    struct packed {
      {%- endif %}
      {%- if field.hw_writable %}
        {%- set bits = "[{}:0]".format(field.width - 1) if field.width > 1 else " " %}
    {{ indent }}logic {{ "{:<6}".format(bits) }} d;
      {%- endif %}
      {%- if is_multifield %}
    } {{ field.name|lower }};
     {%- endif %}
    {%- endfor %}
  } {{ ip_name }}_hw2reg_{{ reg.name|lower }}_{{"m" if is_multireg}}reg_t;
{% endif -%}
{%- endfor %}

  // Register -> HW type for regs interface
  typedef struct packed {
  {%- for reg in registers  %}
  {%- if reg.hw_readable %}
    {{ ip_name }}_reg2hw_{{ reg.name|lower }}_reg_t {% if reg.offsets|length > 1 %}[{{ reg.offsets|length -1 }}:0] {% endif %} {{ reg.name|lower }}; // [62:57]
  {%- endif %}
  {%- endfor %}
  } {{ ip_name }}_reg2hw_t;

  // HW -> register type for regs interface
  typedef struct packed {
  {%- for reg in registers  %}
  {%- if reg.hw_writable %}
    {{ ip_name }}_hw2reg_{{ reg.name|lower }}_reg_t {% if reg.offsets|length > 1 %}[{{ reg.offsets|length -1 }}:0] {% endif %} {{ reg.name|lower }}; // [62:57]
  {%- endif %}
  {%- endfor %}
  } {{ ip_name }}_hw2reg_t;

  // Register offsets for regs interface
  {% for reg in registers %}
  {%- for offset in reg.offsets %}
  {%- set index = "_{}".format(loop.index0) if reg.offsets|length > 1 %}
  {%- set offset_name = "{}_{}{}_OFFSET".format(ip_name, reg.name, index)|upper %}
  parameter logic [{{ offset_bits - 1 }}:0] {{ "{} = {}'h {:x}".format(offset_name, offset_bits, offset) }};
  {%- endfor -%}
  {% endfor %}

  // TODO: unused?
  // Reset values for hwext registers and their fields for regs interface
  {%- for reg in registers  %}
  {%- if reg.external %}
  {%- for field in reg.fields  %}
  parameter logic [{{field.msb}}:{{field.lsb}}] {{ ip_name|upper }}_{{ reg.name|upper }}_{{ field.name|upper }}_RESVAL = {{ field.width }}'h {{ field.reset }};
  {%- endfor %}
  {%- endif %}
  {%- endfor %}

  // Window parameters
  {%- for win in windows  %}
  parameter logic [BlockAw-1:0] {{ ip_name|upper }}_{{ win.name|upper }}_OFFSET = 12'h {{ win.offset }};
  parameter int unsigned        {{ ip_name|upper }}_{{ win.name|upper }}_SIZE   = 'h {{ win.size }};
  parameter int unsigned        {{ ip_name|upper }}_{{ win.name|upper }}_IDX    = {{ win.idx }};
  {%- endfor %}

  // Register index
  typedef enum int {
    {% for reg in registers %}
    {%- for offset in reg.offsets %}
    {{ ip_name|upper }}_{{ reg.name|upper }}{% if reg.offsets|length > 1 %}_{{ loop.index0 }}{% endif %},
    {%- endfor -%}
    {% endfor %}
  } {{ ip_name }}_regs_id_e;

  // Register width information to check illegal writes
  parameter logic [3:0] {{ ip_name|upper }}_REGS_PERMIT [{{ registers|length }}] = '{ {%- for reg in registers %}
    4'b {{ '{:04b}'.format(reg.permit) }}, // index[{{ loop.index0 }}] {{ reg.name|upper }}
    {%- endfor %}
  };

endpackage
