// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `reggen`

`include "prim_assert.sv"

module {{ ip_name|lower }}_regs_reg_top (
  input clk_i,
  input rst_ni,
  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,
  // To HW
  output {{ ip_name|lower }}_reg_pkg::{{ ip_name|lower }}_regs_reg2hw_t reg2hw, // Write
  input  {{ ip_name|lower }}_reg_pkg::{{ ip_name|lower }}_regs_hw2reg_t hw2reg, // Read

  // Integrity check errors
  output logic intg_err_o
);

  import {{ ip_name|lower }}_reg_pkg::* ;

  localparam int AW = 8;
  localparam int DW = 32;
  localparam int DBW = DW/8;                    // Byte Width

  // register signals
  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_be;
  logic [DW-1:0]  reg_rdata;
  logic           reg_error;

  logic          addrmiss, wr_err;

  logic [DW-1:0] reg_rdata_next;
  logic reg_busy;

  tlul_pkg::tl_h2d_t tl_reg_h2d;
  tlul_pkg::tl_d2h_t tl_reg_d2h;


  // incoming payload check
  logic intg_err;
  tlul_cmd_intg_chk u_chk (
    .tl_i(tl_i),
    .err_o(intg_err)
  );

  // also check for spurious write enables
  logic reg_we_err;
  logic [34:0] reg_we_check;
  prim_reg_we_check #(
    .OneHotWidth(35)
  ) u_prim_reg_we_check (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .oh_i  (reg_we_check),
    .en_i  (reg_we && !addrmiss),
    .err_o (reg_we_err)
  );

  logic err_q;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_q <= '0;
    end else if (intg_err || reg_we_err) begin
      err_q <= 1'b1;
    end
  end

  // integrity error output is permanent and should be used for alert generation
  // register errors are transactional
  assign intg_err_o = err_q | intg_err | reg_we_err;

  // outgoing integrity generation
  tlul_pkg::tl_d2h_t tl_o_pre;
  tlul_rsp_intg_gen #(
    .EnableRspIntgGen(1),
    .EnableDataIntgGen(1)
  ) u_rsp_intg_gen (
    .tl_i(tl_o_pre),
    .tl_o(tl_o)
  );

  assign tl_reg_h2d = tl_i;
  assign tl_o_pre   = tl_reg_d2h;

  tlul_adapter_reg #(
    .RegAw(AW),
    .RegDw(DW),
    .EnableDataIntgGen(0)
  ) u_reg_if (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),

    .tl_i (tl_reg_h2d),
    .tl_o (tl_reg_d2h),

    .en_ifetch_i(prim_mubi_pkg::MuBi4False),
    .intg_error_o(),

    .we_o    (reg_we),
    .re_o    (reg_re),
    .addr_o  (reg_addr),
    .wdata_o (reg_wdata),
    .be_o    (reg_be),
    .busy_i  (reg_busy),
    .rdata_i (reg_rdata),
    .error_i (reg_error)
  );

  // cdc oversampling signals

  assign reg_rdata = reg_rdata_next ;
  assign reg_error = addrmiss | wr_err | intg_err;

  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
{%- for reg in registers  %}
  {%- for offset in reg.offsets %}
    {%- set is_multifields = reg.fields|length > 1 %}
    {%- set multireg_idx = loop.index0 %}
    {%- set is_multireg = (reg.offsets|length > 1) %}
    {%- set index = ('_' ~ multireg_idx|string) if is_multireg %}
    {%- if reg.needs_read_en %}
  logic {{ reg.name|lower }}{{ index }}_re;
    {%- endif -%}
    {%- if reg.needs_write_en %}
  logic {{ reg.name|lower }}{{ index }}_we;
    {%- endif -%}
    {%- for field in reg.fields %}
      {%- set field_name = ('_' ~ field.name|lower) if is_multifields %}
      {%- set width = "[{}:0] ".format(field.width - 1) if field.width > 1 %}
      {%- if field.sw_readable %} 
  logic {{ width ~ reg.name|lower ~ index ~ field_name }}_qs;
      {%- endif -%}
      {%- if field.sw_writable %} 
  logic {{ width ~ reg.name|lower ~ index ~ field_name }}_wd;
      {%- endif -%}
    {%- endfor -%}
  {%- endfor -%}
{%- endfor %}

  // Register instances
{%- set assign = namespace(expr="") %}
{%- for reg in registers  %}
  {%- for offset in reg.offsets %}
    {%- set is_multireg = (reg.offsets|length > 1) %}
    {%- set multireg_idx = loop.index0 if is_multireg %}
    {%- set regname = reg.name|lower ~ ("_{}".format(loop.index0) if is_multireg) %}
    {%- set is_multifields = reg.fields|length > 1 %}
      {%- if is_multireg %}
  // Subregister {{loop.index0}} of Multireg {{ reg.name|lower }}
      {%- endif %}
  // R[{{ regname }}]: V({{ reg.external }})
    {%- if reg.needs_qe%}
  logic {{ regname }}_qe;
  logic {{ '[{}:0] {}'.format(reg.fields|length - 1, regname) }}_flds_we;
  assign {{ regname }}_qe = &{{ regname }}_flds_we;
    {%- endif -%}
    {%- if reg.sw_write_en and reg.needs_write_en %}
  // Create REGWEN-gated WE signal
  logic {{ regname }}_gated_we;
      {%- set assign.expr = ('clk_base_name_' ~ regname ~ '_we')|lower -%}
      {%- if reg.sw_write_en %}
        {%- set wr_en_sig_name = reg.fields[0].write_en_signal.name|lower -%}
        {%- set wr_en_reg_name = reg.fields[0].write_en_signal.parent_name|lower -%}
        {%- set assign.expr = ('clk_base_name_' ~ regname|lower ~ '_regwen') if reg.async else "{}_qs".format(wr_en_reg_name) -%}
        {%- if reg.fields[0].write_en_signal.mubi %}
          {%- set width = reg.fields[0].write_en_signal.width -%}
          {%- set assign.expr = "prim_mubi_pkg::mubi{}_test_true_strict(prim_mubi_pkg::mubi{}_t'({}_qs))".format(width, width, wr_en_sig_name)|lower -%}
        {%- endif %}
      {%- endif %}
  assign {{ regname }}_gated_we = {{ regname }}_we & {{ assign.expr }};
    {%- endif -%}
    {%- for field in reg.fields  %}
      {%- set field_name = ('_' ~ field.name|lower) if is_multifields -%}
      {%- set property = ('.' ~ field.name|lower) if is_multifields -%}
      {%- if is_multifields %}
  //   F{{ '[{}]: {}:{}'.format(field.name|lower, field.msb, field.lsb) }}
      {%- endif %}
  prim_subreg{{ '_ext' if reg.external }} #(
    .DW    ({{ field.width }})
      {%- if not reg.external -%}
    ,
    .SwAccess(prim_subreg_pkg::SwAccessW0C),
    .RESVAL  ({{ field.width }}'h{{ field.reset }}),
    .Mubi    (1'b{{ field.mubi|int }})
      {%- endif %}
  ) u_{{ regname ~ field_name }} (
      {%- if not reg.external %}
    .clk_i   (clk_i),
    .rst_ni  (rst_ni),
      {%- if reg.shadowed -%}
    .rst_shadowed_ni (rst_shadowed_ni),
      {%- endif %}
      {% endif %}
    // from register interface
      {%- if reg.external or reg.shadowed %}
    .re     ({% if reg.sw_readable or reg.shadowed %}{{ regname }}_re{% else %}1'b0{% endif %}),
      {%- endif %}
    .we     ({% if reg.sw_writable %}{{ regname ~ ('_gated' if reg.sw_write_en) }}_we{% else %}1'b0{% endif %}),
    .wd     ({% if reg.sw_writable %}{{ regname ~ field_name }}_wd{% else %}'0{% endif %}),

    {% set sig_name = reg.name|lower ~ ("[{}]".format(multireg_idx) if is_multireg) ~ property -%}
    // from internal hardware
      {%- if not reg.external %}
    .de     ({% if reg.hw_writable %}hw2reg.{{ sig_name }}.de{% else %}1'b0{% endif %}),
      {%- endif %}
    .d      ({% if reg.hw_writable %}hw2reg.{{ sig_name }}.d{% else %}'0{% endif %}),

    // to internal hardware
      {%- if reg.external %}
    .qre    ({% if reg.hwre %}{{ regname }}.re{% endif %}),
      {%- endif %}
    .qe     ({% if reg.hw_readable %}{{ regname }}_flds_we[{{ loop.index0 }}]{% endif %}),
    .q      ({% if reg.hw_readable %}reg2hw.{{ sig_name }}.q{% endif %}),
    .ds     ({% if reg.async and reg.hw_writable %}{{ regname }}_ds{% endif %}),
      {%- if not reg.shadowed %}

    // to register interface (read)
    .qs     ({% if reg.sw_readable %}{{ regname ~ field_name }}_qs{% endif %})
      {%- else %}
    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
        {%- if reg.async %}
    .err_update  (async_{{ regname ~ field_name }}_err_update),
    .err_storage (async_{{ regname ~ field_name }}_err_storage)
        {%- else %}
    .err_update  ({{ regname ~ field_name }}_update_err),
    .err_storage ({{ regname ~ field_name }}_storage_err)
        {%- endif %}
      {%- endif %}
  );
    {%- if reg.external and reg.sw_writable %}
  assign reg2hw.{{ sig_name }}.qe = {{ regname }}_qe;
    {%- endif %}
    {% endfor -%}
  {% endfor %}
{% endfor %}

  logic [34:0] addr_hit;
  always_comb begin
    addr_hit = '0;
{%- set ns = namespace(counter=0) %}
{%- for reg in registers %}
  {%- for offset in reg.offsets %}
    {%- set index = "{:>2}".format(ns.counter) %}
    {%- set ns.counter = ns.counter + 1 %}
    addr_hit[{{ index }}] = (reg_addr == {{ (ip_name ~ '_' ~ reg.name)|upper }}{% if reg.offsets|length > 1 %}_{{ loop.index0 }}{% endif %}_OFFSET);
  {%- endfor %}
{%- endfor %}
  end

  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;

  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
{%- set ns = namespace(counter=0) %}
{%- for reg in registers %}
  {%- set outer_loop = loop -%}
  {%- for offset in reg.offsets %}
    {%- set index = "{:>2}".format(ns.counter) %}
    {%- set ns.counter = ns.counter + 1 %}
    {%- if loop.first and outer_loop.first %}
              (
    {%- endif %}
               (addr_hit[{{ index }}] & (|({{ ip_name|upper }}_REGS_PERMIT[{{ index }}] & ~reg_be))) 
    {%- if loop.last and outer_loop.last %}));{% else %} |{% endif %}
  {%- endfor %}
{%- endfor %}
  end

  // Generate write-enables
{%- set ns = namespace(re_index=0) -%}
{%- for reg in registers  %}
  {%- for offset in reg.offsets %}
    {%- set multireg_index = ('_' ~ loop.index0|string) if reg.offsets|length > 1 %}
    {%- set regname = "{}{}".format(reg.name, multireg_index)|lower %}
    {%- if reg.needs_read_en %}
  assign {{ regname }}_re = addr_hit[{{ ns.re_index }}] & reg_re & !reg_error;
    {%- endif %}
    {%- if reg.needs_write_en %}
  assign {{ regname }}_we = addr_hit[{{ ns.re_index }}] & reg_we & !reg_error;
    {%- endif %}
    {%- set ns.re_index = ns.re_index + 1 %}
    {%- for field in reg.fields %}
      {%- set field_name = ('_' ~ field.name|lower) if reg.fields|length > 1 %}
      {%- if reg.sw_writable and not reg.async %}
      {%- set expr = "{}{}{}".format(reg.name, field_name, multireg_index)|lower %}
        {%- set bit_index = "{}:{}".format(field.msb, field.lsb) if field.width > 1 else field.msb %}
  assign {{ expr }}_wd = reg_wdata[{{ bit_index }}];
      {%- endif %}
    {%- endfor %}
  {%- endfor %}
{% endfor %}

  // Assign write-enables to checker logic vector.
  always_comb begin
    reg_we_check = '0;
{%- set ns = namespace(counter=0) %}
{%- for reg in registers %}
  {%- for offset in reg.offsets %}
    {%- set multireg_index = ('_' ~ loop.index0|string) if reg.offsets|length > 1 %}
    {%- set expr = "{}{}{}_we".format(reg.name|lower, multireg_index, "_gated" if not reg.async and reg.sw_write_en) if reg.needs_write_en else "1'b0" %}
    reg_we_check[{{ ns.counter }}] = {{ expr }};
    {%- set ns.counter = ns.counter + 1 %}
  {%- endfor %}
{%- endfor %}
  end

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
{%- set ns = namespace(counter=0) %}
{%- for reg in registers %}
  {%- for offset in reg.offsets %}
    {%- set multireg_index = ('_' ~ loop.index0|string) if reg.offsets|length > 1 %}
      addr_hit[{{ ns.counter }}]: begin
    {%- set ns.counter = ns.counter + 1 %}
    {%- for field in reg.fields %}
      {%- set field_name = ('_' ~ field.name|lower) if reg.fields|length > 1 %}
      {%- set index = "{}:{}".format(field.msb, field.lsb) if field.width > 1 else field.msb %}
      {%- set expr = "{}{}{}_qs".format(reg.name, field_name, multireg_index) if field.sw_readable else "'0" %}
        reg_rdata_next{{ "[{}] = {}".format(index, expr)|lower }};
    {%- endfor %}
      end
  {% endfor -%}
{%- endfor %}
      default: begin
        reg_rdata_next = '1;
      end
    endcase
  end

  // shadow busy
  logic shadow_busy;
  assign shadow_busy = 1'b0;

  // register busy
  assign reg_busy = shadow_busy;

  // Unused signal tieoff

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint waivers
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata;
  assign unused_be = ^reg_be;

  // Assertions for Register Interface
  `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
  `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)

  `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)

  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)

  // this is formulated as an assumption such that the FPV testbenches do disprove this
  // property by mistake
  //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)

endmodule
