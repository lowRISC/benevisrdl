// Copyright lowRISC contributors (OpenTitan project).
// Licensed under the Apache License, Version 2.0, see LICENSE for details.
// SPDX-License-Identifier: Apache-2.0
//
// Register Top module auto-generated by `rdl2ot`

`include "prim_assert.sv"
{%- set registers = interface.regs %}
{%- set windows = interface.windows %}
{%- set has_windows = windows|length > 0 %}
{%- set has_regs = registers|length > 0 %}
{%- set interface_name = ("_" + interface.name) if interface.name %}
{%- set clk_name = "aon_" %}

module {{ ip_name|lower }}{{interface_name}}_reg_top (
  input clk_i,
  input rst_ni,
{%- if interface.any_async_clk %}
  input clk_{{ clk_name }}i,
  input rst_{{ clk_name }}ni,
{%- endif %}
  input  tlul_pkg::tl_h2d_t tl_i,
  output tlul_pkg::tl_d2h_t tl_o,

{%- if has_windows %}

  // Output port for window
  output tlul_pkg::tl_h2d_t tl_win_o,
  input  tlul_pkg::tl_d2h_t tl_win_i,
{%- endif %}

{%- if has_regs %}
  // To HW
  output {{ ip_name|lower }}_reg_pkg::{{ ip_name|lower }}{{interface_name}}_reg2hw_t reg2hw, // Write
  input  {{ ip_name|lower }}_reg_pkg::{{ ip_name|lower }}{{interface_name}}_hw2reg_t hw2reg, // Read
  {%- endif %}

  // Integrity check errors
  output logic intg_err_o
);

  import {{ ip_name|lower }}_reg_pkg::* ;

{%- if has_windows %}

  // Add an unloaded flop to make use of clock / reset
  // This is done to specifically address lint complaints of unused clocks/resets
  // Since the flop is unloaded it will be removed during synthesis
  logic unused_reg;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      unused_reg <= '0;
    end else begin
      unused_reg <= tl_i.a_valid;
    end
  end


  // Since there are no registers in this block, commands are routed through to windows which
  // can report their own integrity errors.
  assign intg_err_o = 1'b0;

  // outgoing integrity generation
  tlul_pkg::tl_d2h_t tl_o_pre;
  tlul_rsp_intg_gen #(
    .EnableRspIntgGen(1),
    .EnableDataIntgGen(0)
  ) u_rsp_intg_gen (
    .tl_i(tl_o_pre),
    .tl_o(tl_o)
  );

  assign tl_win_o = tl_i;
  assign tl_o_pre = tl_win_i;

{%- endif %}

{%- if has_regs %}

  localparam int AW = {{ interface.offset_bits }};
  localparam int DW = 32;
  localparam int DBW = DW/8;                    // Byte Width
{%- endif %}

{%- if has_regs %}

  // register signals
  logic           reg_we;
  logic           reg_re;
  logic [AW-1:0]  reg_addr;
  logic [DW-1:0]  reg_wdata;
  logic [DBW-1:0] reg_be;
  logic [DW-1:0]  reg_rdata;
  logic           reg_error;

  logic          addrmiss, wr_err;

  logic [DW-1:0] reg_rdata_next;
  logic reg_busy;

  tlul_pkg::tl_h2d_t tl_reg_h2d;
  tlul_pkg::tl_d2h_t tl_reg_d2h;


  // incoming payload check
  logic intg_err;
  tlul_cmd_intg_chk u_chk (
    .tl_i(tl_i),
    .err_o(intg_err)
  );

  // also check for spurious write enables
  logic reg_we_err;
  logic [{{ interface.num_regs - 1 }}:0] reg_we_check;
  prim_reg_we_check #(
    .OneHotWidth({{ interface.num_regs }})
  ) u_prim_reg_we_check (
    .clk_i(clk_i),
    .rst_ni(rst_ni),
    .oh_i  (reg_we_check),
    .en_i  (reg_we && !addrmiss),
    .err_o (reg_we_err)
  );

  logic err_q;
  always_ff @(posedge clk_i or negedge rst_ni) begin
    if (!rst_ni) begin
      err_q <= '0;
    end else if (intg_err || reg_we_err) begin
      err_q <= 1'b1;
    end
  end

  // integrity error output is permanent and should be used for alert generation
  // register errors are transactional
  assign intg_err_o = err_q | intg_err | reg_we_err;

  // outgoing integrity generation
  tlul_pkg::tl_d2h_t tl_o_pre;
  tlul_rsp_intg_gen #(
    .EnableRspIntgGen(1),
    .EnableDataIntgGen(1)
  ) u_rsp_intg_gen (
    .tl_i(tl_o_pre),
    .tl_o(tl_o)
  );

  assign tl_reg_h2d = tl_i;
  assign tl_o_pre   = tl_reg_d2h;

  tlul_adapter_reg #(
    .RegAw(AW),
    .RegDw(DW),
    .EnableDataIntgGen(0)
  ) u_reg_if (
    .clk_i  (clk_i),
    .rst_ni (rst_ni),

    .tl_i (tl_reg_h2d),
    .tl_o (tl_reg_d2h),

    .en_ifetch_i(prim_mubi_pkg::MuBi4False),
    .intg_error_o(),

    .we_o    (reg_we),
    .re_o    (reg_re),
    .addr_o  (reg_addr),
    .wdata_o (reg_wdata),
    .be_o    (reg_be),
    .busy_i  (reg_busy),
    .rdata_i (reg_rdata),
    .error_i (reg_error)
  );

  // cdc oversampling signals

  assign reg_rdata = reg_rdata_next ;
  assign reg_error = addrmiss | wr_err | intg_err;

  // Define SW related signals
  // Format: <reg>_<field>_{wd|we|qs}
  //        or <reg>_{wd|we|qs} if field == 1 or 0
{%- endif %}
{%- for reg in registers  %}
  {%- for offset in reg.offsets %}
    {%- set multireg_idx = loop.index0 %}
    {%- set index = ('_' ~ multireg_idx|string) if reg.is_multireg %}
    {%- if reg.needs_read_en %}
  logic {{ reg.name|lower }}{{ index }}_re;
    {%- endif %}
    {%- if reg.needs_write_en %}
  logic {{ reg.name|lower }}{{ index }}_we;
    {%- endif %}
    {%- for field in reg.fields %}
      {%- set field_name = ('_' ~ field.name|lower) if reg.is_multifields %}
      {%- set width = "[{}:0] ".format(field.width - 1) if field.width > 1 %}
      {%- if not reg.async_clk and field.sw_readable %} 
  logic {{ width ~ reg.name|lower ~ index ~ field_name }}_qs;
      {%- endif %}
      {%- if not reg.async_clk and field.sw_writable %} 
  logic {{ width ~ reg.name|lower ~ index ~ field_name }}_wd;
      {%- endif %}
    {%- endfor %}
    {%- if reg.async_clk %} 
  logic [{{ reg.msb }}:0] {{reg.name ~ index }}_qs;
  logic {{ reg.name ~ index }}_busy;
    {%- endif %}
  {%- endfor %}
{%- endfor %}

{%- if interface.any_async_clk %}

  // Define register CDC handling.
  // CDC handling is done on a per-reg instead of per-field boundary.
{{ space }}  
  {%- for reg in registers  %}
    {%- if reg.async_clk %} 
      {%- for offset in reg.offsets %}

        {%- set multireg_idx = loop.index0 %}
        {%- set index = ('_' ~ multireg_idx|string) if reg.is_multireg %}
        {%- set sig_name = (clk_name ~ reg.name ~ index)|lower %}

        {%- set src_we_expr = "{}_we".format(reg.name ~ index) if reg.needs_write_en else "'0" %}
        {%- set src_wd_expr = "reg_wdata[{}:0]".format(reg.msb) if reg.needs_write_en else "'0" %}
        {%- set src_re_expr = "{}_re".format(reg.name ~ index) if reg.needs_read_en else "'0" %}
        {%- set src_regwen_expr = "{}_qs".format(reg.swwe) if reg.swwe else "'0" %}
        {%- set dst_we_expr = "{}_we".format(sig_name) if reg.needs_write_en %}
        {%- set dst_wd_expr = "{}_wdata".format(sig_name) if reg.needs_write_en %}
        {%- set dst_re_expr = "{}_re".format(sig_name) if reg.needs_read_en %}
        {%- set dst_qe_expr = "{}_qe".format(sig_name) if reg.hw_writable else "'0" %}
        {%- set dst_wr_req = "1" if reg.hw_writable else "0" %}
        {%- set dst_ds_expr = "{}_ds".format(sig_name) if reg.hw_writable else "'0" %}
        {%- set dst_regwen_expr = "{}_regwen".format(sig_name) if reg.sw_write_en %}
        {%- set reset_expr = "{}'h{:x}".format(reg.msb + 1, reg.reset)  %}

        {%- for field in reg.fields %}
          {%- set bit_index = "[{}:0] ".format(field.width - 1) if field.msb != field.lsb %}
          {%- set field_name = ('_' ~ field.name|lower) if reg.is_multifields %}
          {%- if reg.hw_writable %}
  logic {{ bit_index }} {{ (sig_name ~ field_name ~ index )|lower }}_ds_int;
          {%- endif %}
          {%- if field.sw_readable %}
  logic {{ bit_index }} {{ (sig_name ~ field_name ~ index )|lower }}_qs_int;
          {%- endif %}
        {%- endfor %}
        {%- if reg.hw_writable %}
  logic [{{ reg.msb }}:0] {{ sig_name }}_ds;
  logic {{ dst_qe_expr }};
        {%- endif %}
  logic [{{ reg.msb }}:0] {{ sig_name }}_qs;
        {%- if reg.needs_write_en %}
  logic [{{ reg.msb }}:0] {{ sig_name }}_wdata;
  logic {{ sig_name }}_we;
  logic unused_{{ sig_name }}_wdata;
        {%- endif %}
        {%- if reg.needs_read_en %}
  logic {{ dst_re_expr }};
        {%- endif %}
        {%- if reg.sw_write_en %}
  logic {{ dst_regwen_expr }};
        {%- endif %}

  always_comb begin
    {{ sig_name }}_qs = {{ reset_expr }};
        {%- if reg.hw_writable %}
    {{ dst_ds_expr }} = {{ reset_expr }};
        {%- endif %}
        {%- for field in reg.fields %}
          {%- set bits = "{}:{}".format(field.msb, field.lsb) if field.msb != field.lsb else field.msb %}
          {%- set bit_index = "[{}]".format(bits) if reg.is_multifields %}
          {%- set field_name = ('_' ~ field.name|lower) if reg.is_multifields %}

          {%- if reg.hw_writable and field.sw_readable %}
    {{ dst_ds_expr }}{{ bit_index }} = {{ sig_name ~ field_name ~ index }}_ds_int;
          {%- endif %}

          {%- if field.sw_readable %}
    {{ sig_name }}_qs{{ bit_index }} = {{ sig_name  ~ field_name ~ index  }}_qs_int;
          {%- endif %}
        {%- endfor %}
  end

  prim_reg_cdc #(
    .DataWidth({{ reg.msb + 1 }}),
    .ResetVal({{ reset_expr }}),
    .BitMask({{ "{}'h{:x}".format(reg.msb + 1, reg.bitmask) }}),
    .DstWrReq({{ dst_wr_req }})
  ) u_{{ reg.name ~ index }}_cdc (
    .clk_src_i    (clk_i),
    .rst_src_ni   (rst_ni),
    .clk_dst_i    (clk_{{ clk_name }}i),
    .rst_dst_ni   (rst_{{ clk_name }}ni),
    .src_regwen_i ({{ src_regwen_expr }}),
    .src_we_i     ({{ src_we_expr }}),
    .src_re_i     ({{ src_re_expr }}),
    .src_wd_i     ({{ src_wd_expr }}),
    .src_busy_o   ({{ reg.name ~ index }}_busy),
    .src_qs_o     ({{ reg.name ~ index }}_qs), // for software read back
    .dst_update_i ({{ dst_qe_expr }}),
    .dst_ds_i     ({{ dst_ds_expr }}),
    .dst_qs_i     ({{ sig_name }}_qs),
    .dst_we_o     ({{ dst_we_expr }}),
    .dst_re_o     ({{ dst_re_expr }}),
    .dst_regwen_o ({{ dst_regwen_expr }}),
    .dst_wd_o     ({{ dst_wd_expr }})
  );
        {%- if reg.needs_write_en %}
  assign unused_{{ sig_name }}_wdata =
      ^{{ sig_name }}_wdata;
        {%- endif %}
{{ space -}}
      {% endfor %}
    {%- endif %}
  {%- endfor %}
{%- endif %}

{%- if has_regs %}
{{- space }}
  // Register instances
{%- endif %}

{%- set assign = namespace(expr="") %}
{%- for reg in registers  %}
  {%- for offset in reg.offsets %}
    {%- set multireg_idx = loop.index0 if reg.is_multireg %}
    {%- set multireg_suffix = "_{}".format(multireg_idx) if reg.is_multireg %}
    {%- set regname = reg.name|lower ~ multireg_suffix %}
    {%- set clk_prefix = clk_name if reg.async_clk %}
    {%- if reg.is_multireg %}
  // Subregister {{multireg_idx}} of Multireg {{ reg.name|lower }}
    {%- endif %}
{{- space }}
  // R[{{ regname }}]: V({{ reg.external }})
    {%- if reg.needs_qe %}
  logic {{ regname }}_qe;
    {%- endif %}
    {%- if reg.needs_int_qe %}
  logic {{ '[{}:0] {}'.format(reg.fields|length - 1, regname) }}_flds_we;
    {%- endif %}
    {%- if reg.needs_qe and reg.external %}
  assign {{clk_prefix ~ regname }}_qe = &{{"{}".format(regname) }}_flds_we;
    {%- endif %}
    {%- if reg.async_clk and reg.hw_writable %}
  assign {{clk_prefix ~ regname }}_qe = |{{"{}".format(regname) }}_flds_we;
    {%- endif %}
    {%- if reg.sw_write_en and reg.needs_write_en %}
  // Create REGWEN-gated WE signal
  logic {{ regname }}_gated_we;
      {%- set assign.expr = ('clk_base_name_' ~ regname ~ '_we')|lower %}
      {%- if reg.sw_write_en %}
        {%- set wr_en_sig_name = reg.fields[0].write_en_signal.name|lower %}
        {%- set wr_en_reg_name = reg.fields[0].write_en_signal.parent_name|lower %}
        {%- set assign.expr = ('clk_base_name_' ~ regname|lower ~ '_regwen') if reg.async else "{}_qs".format(wr_en_reg_name) %}
        {%- if reg.fields[0].write_en_signal.mubi %}
          {%- set width = reg.fields[0].write_en_signal.width %}
          {%- set assign.expr = "prim_mubi_pkg::mubi{}_test_true_strict(prim_mubi_pkg::mubi{}_t'({}_qs))".format(width, width, wr_en_sig_name)|lower %}
        {%- endif %}
      {%- endif %}
  assign {{ regname }}_gated_we = {{ regname }}_we & {{ assign.expr }};
    {%- endif %}
    {%- for field in reg.fields  %}
      {%- set field_name = "_{}{}".format(field.name, multireg_suffix)|lower if reg.is_multifields %}
      {%- set property = ".{}".format(field.name)|lower if reg.is_multifields %}
      {%- set bit_index = "[{}:{}]".format(field.msb, field.lsb) if field.msb != field.lsb else "[{}]".format(field.msb) %}
      {%- if reg.is_multifields %}
  //   F{{ '[{}{}]: {}:{}'.format(field.name, multireg_suffix, field.msb, field.lsb)|lower }}
      {%- endif %}
  prim_subreg{{ '_ext' if reg.external }} #(
    .DW      ({{ field.width }})
      {%- if not reg.external -%}
    ,
    .SwAccess(prim_subreg_pkg::SwAccess{{ field.reggen_sw_access }}),
    .RESVAL  ({{ "{}'h{:x}".format(field.width, field.reset) }}),
    .Mubi    (1'b{{ field.mubi|int }})
      {%- endif %}
  ) u_{{ regname ~ field_name }} (
      {%- if not reg.external %}
    .clk_i   (clk_{{ clk_prefix if reg.async_clk }}i),
    .rst_ni  (rst_{{ clk_prefix if reg.async_clk }}ni),
      {%- if reg.shadowed %}
    .rst_shadowed_ni (rst_shadowed_ni),
      {%- endif %}
      {%- endif %}
{{- space }}

    {%- set sig_name = (reg.name ~ ("[{}]".format(multireg_idx) if reg.is_multireg) ~ property)|lower -%}
    {%- set suffix = "_int" if reg.async_clk %}

    // from register interface
      {%- if reg.external or reg.shadowed %}
    .re     ({{ "{}{}{}_re".format(clk_prefix, reg.name, multireg_suffix)|lower if reg.sw_readable or reg.shadowed else "1'b0" }}),
      {%- endif %}
    .we     ({{ "{}{}_we".format(clk_prefix ~ regname, ("_gated" if reg.sw_write_en)) if reg.sw_writable else "1'b0"  }}),
    .wd     ({{ "{}{}{}_wd{}{}".format(clk_prefix, regname, field_name if not reg.async_clk, "ata" if reg.async_clk, bit_index if reg.async_clk) if reg.sw_writable else "'0"  }}),

    // from internal hardware
      {%- if not reg.external %}
    .de     ({% if reg.hw_writable %}hw2reg.{{ sig_name }}.de{% else %}1'b0{% endif %}),
      {%- endif %}
    .d      ({% if reg.hw_writable %}hw2reg.{{ sig_name }}.d{% else %}'0{% endif %}),

    // to internal hardware
      {%- if reg.external %}
    .qre    ({% if reg.hwre %}{{ regname }}.re{% endif %}),
      {%- endif %}
    .qe     ({{ "{}_flds_we[{}]".format(regname, loop.index0) if reg.needs_int_qe  }}),
    .q      ({{ "reg2hw.{}.q".format(sig_name) if reg.hw_readable }}),
    .ds     ({{ "{}{}{}_ds{}".format(clk_prefix, regname, field_name, suffix) if reg.async_clk and reg.hw_writable }}),

    // to register interface (read)
    .qs     ({{ "{}{}_qs{}".format(clk_prefix, regname ~ field_name, suffix) if reg.sw_readable }})
      {%- if reg.shadowed -%}
      ,

    // Shadow register phase. Relevant for hwext only.
    .phase  (),

    // Shadow register error conditions
        {%- if reg.async %}
    .err_update  (async_{{ regname ~ field_name }}_err_update),
    .err_storage (async_{{ regname ~ field_name }}_err_storage)
        {%- else %}
    .err_update  ({{ regname ~ field_name }}_update_err),
    .err_storage ({{ regname ~ field_name }}_storage_err)
        {%- endif %}
      {%- endif %}
  );
    {%- if reg.external and reg.sw_writable %}
  assign reg2hw.{{ sig_name }}.qe = {{ regname }}_qe;
    {%- endif %}
{{- space }}
{{ space }}
    {%- endfor %}
  {%- endfor %}
{{ space }}  
{%- endfor %}

{%- if has_regs %}

  logic [{{interface.num_regs - 1 }}:0] addr_hit;
  always_comb begin
  {%- set ns = namespace(counter=0) %}
  {%- for reg in registers %}
    {%- for offset in reg.offsets %}
      {%- set index = "{:>2}".format(ns.counter) %}
      {%- set ns.counter = ns.counter + 1 %}
    addr_hit[{{ index }}] = (reg_addr == {{ (ip_name ~ '_' ~ reg.name)|upper }}{% if reg.offsets|length > 1 %}_{{ loop.index0 }}{% endif %}_OFFSET);
    {%- endfor %}
  {%- endfor %}
  end

  assign addrmiss = (reg_re || reg_we) ? ~|addr_hit : 1'b0 ;

  // Check sub-word write is permitted
  always_comb begin
    wr_err = (reg_we &
  {%- set ns = namespace(counter=0) %}
  {%- set interface_name = ("_" + interface.name) if interface.name -%}
  {%- for reg in registers %}
    {%- set outer_loop = loop -%}
    {%- for offset in reg.offsets %}
      {%- set index = "{:>2}".format(ns.counter) %}
      {%- set ns.counter = ns.counter + 1 %}
      {%- if loop.first and outer_loop.first -%} ( {%- endif %}
               (addr_hit[{{ index }}] & (|({{ (ip_name ~ interface_name)|upper}}_PERMIT[{{ index }}] & ~reg_be))) 
      {%- if loop.last and outer_loop.last %}));{% else %} |{% endif %}
    {%- endfor %}
  {%- endfor %}
  end

  // Generate write-enables
  {%- set ns = namespace(re_index=0) -%}
  {%- for reg in registers  %}
    {%- for offset in reg.offsets %}
      {%- set multireg_index = ('_' ~ loop.index0|string) if reg.offsets|length > 1 %}
      {%- set regname = "{}{}".format(reg.name, multireg_index)|lower %}
      {%- if reg.needs_read_en %}
  assign {{ regname }}_re = addr_hit[{{ ns.re_index }}] & reg_re & !reg_error;
      {%- endif %}
      {%- if reg.needs_write_en %}
  assign {{ regname }}_we = addr_hit[{{ ns.re_index }}] & reg_we & !reg_error;
      {%- endif %}
      {%- set ns.re_index = ns.re_index + 1 %}
      {%- if reg.sw_writable and not reg.async_clk %}
        {%- for field in reg.fields %}
          {%- set field_name = ('_' ~ field.name|lower) if reg.is_multifields %}
            {%- set expr = "{}{}{}".format(reg.name, field_name, multireg_index)|lower %}
            {%- set bit_index = "{}:{}".format(field.msb, field.lsb) if field.width > 1 else field.msb %}
  assign {{ expr }}_wd = reg_wdata[{{ bit_index }}];
        {%- endfor %}
      {%- endif %}
    {%- endfor %}
  {% endfor %}

  // Assign write-enables to checker logic vector.
  always_comb begin
  {%- set ns = namespace(counter=0) %}
  {%- for reg in registers %}
    {%- for offset in reg.offsets %}
      {%- set multireg_index = ('_' ~ loop.index0|string) if reg.offsets|length > 1 %}
      {%- set expr = "{}{}{}_we".format(reg.name|lower, multireg_index, "_gated" if not reg.async and reg.sw_write_en) if reg.needs_write_en else "1'b0" %}
    reg_we_check[{{ ns.counter }}] = {{ expr }};
      {%- set ns.counter = ns.counter + 1 %}
    {%- endfor %}
  {%- endfor %}
  end

  // Read data return
  always_comb begin
    reg_rdata_next = '0;
    unique case (1'b1)
  {%- set ns = namespace(counter=0) %}
  {%- for reg in registers %}
    {%- for offset in reg.offsets %}
      {%- set multireg_index = ('_' ~ loop.index0|string) if reg.is_multireg %}
      addr_hit[{{ ns.counter }}]: begin
      {%- set ns.counter = ns.counter + 1 %}
      {%- if reg.async_clk %}
        reg_rdata_next = DW'({{ "{}{}_qs".format(reg.name, multireg_index)|lower }});
      {%- else %}
        {%- for field in reg.fields %}
            {%- set field_name = ('_' ~ field.name|lower) if reg.is_multifields %}
            {%- set index = "{}:{}".format(field.msb, field.lsb) if field.width > 1 else field.msb %}
            {%- set expr = "{}{}{}_qs".format(reg.name, field_name, multireg_index) if field.sw_readable else "'0" %}
        reg_rdata_next{{ "[{}] = {}".format(index, expr)|lower }};
        {%- endfor %}
      {%- endif %}
      end
{{ space }}
    {%- endfor -%}
  {%- endfor %}
      default: begin
        reg_rdata_next = '1;
      end
    endcase
  end

  // shadow busy
  logic shadow_busy;
  assign shadow_busy = 1'b0;

  // register busy

  {%- if interface.all_async_clk %}
  assign reg_busy = shadow_busy;
  {% else %}
  logic reg_busy_sel;
  assign reg_busy = (reg_busy_sel | shadow_busy) & tl_i.a_valid;
  always_comb begin
    reg_busy_sel = '0;
    unique case (1'b1)
    {%- for index, busy_signal in interface.async_registers %}
      addr_hit[{{ index }}]: begin
        reg_busy_sel = {{ busy_signal }}_busy;
      end
    {%- endfor %}
      default: begin
        reg_busy_sel  = '0;
      end
    endcase
  end
  {%- endif %}


  // Unused signal tieoff

  // wdata / byte enable are not always fully used
  // add a blanket unused statement to handle lint waivers
  logic unused_wdata;
  logic unused_be;
  assign unused_wdata = ^reg_wdata;
  assign unused_be = ^reg_be;

  // Assertions for Register Interface
  `ASSERT_PULSE(wePulse, reg_we, clk_i, !rst_ni)
  `ASSERT_PULSE(rePulse, reg_re, clk_i, !rst_ni)

  `ASSERT(reAfterRv, $rose(reg_re || reg_we) |=> tl_o_pre.d_valid, clk_i, !rst_ni)

  `ASSERT(en2addrHit, (reg_we || reg_re) |-> $onehot0(addr_hit), clk_i, !rst_ni)

  // this is formulated as an assumption such that the FPV testbenches do disprove this
  // property by mistake
  //`ASSUME(reqParity, tl_reg_h2d.a_valid |-> tl_reg_h2d.a_user.chk_en == tlul_pkg::CheckDis)
{%- endif %}

endmodule
